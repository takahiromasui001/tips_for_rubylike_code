= Enumerableのメソッドで繰り返し処理をRubyっぽくする
「Rubyっぽい」コードを書くための手段として、次に提案するのは繰り返し処理におけるEnumerableのメソッドの利用です。

繰り返し処理は大抵のプログラムで用いられる頻出の処理です。
例えばデータベースから取り出したレコードのリストに同じ処理を行う、
といった用途で用いられることはかなり多いかと思います。
繰り返し処理をカバーすることで、コードをコスパ良く「Rubyっぽく」できるはず。

そのための手段として用いるのがEnumerableのメソッドです。
EnumerableはRubyの組込ライブラリの1つで、繰り返し処理に関連する便利なメソッドを提供してくれる Mix-in になります。
ちなみに読み方は「エニュメラブル(発音記号: injúːmərəbl, "ニュ"のあたりにアクセント)」です。

Enumerableのメソッドの例としては map や select です。
これらのメソッドはRuby開発者がとても好んで用いていますので、
積極的に取り入れることで「Rubyっぽい」コードを書けるようになります。

Enumerableのメソッドを使うなんて当たり前でしょ？
という方はすみません、この章から得られることは無いかもしれません。

ただ、map?select? 聞いたことあるけど...という方、
もしくはmapやselectは分かるがEnumerableって何よ？という方は、
この章を読むことで得られる事があると思いますので、続きを読んでいただければ幸いです。

== Rubyにおける繰り返し処理の基本: eachメソッド
最初に前提知識としてRubyにおける繰り返し処理の基本について説明します。
Rubyにおける反復処理は、オブジェクトの各要素に「ある処理」を適用する事で実現される事が多いです。
eachはその考えを最も分かりやすく表現しているメソッドです。

(whileに関して触れるかどうかは悩み所,,,)

Rubyでは繰り返し処理に基本eachを用います。

//emlist{
list = (1..3).to_a
list.each { |item| p item + 10 }
//}
//emlist{
# 出力結果
11
12
13
14
15
//}

繰り返しごとにブロック引数(上の例では item )にはオブジェクトの各要素が順に入ります。
また戻り値はレシーバ(上の例では list )になります。
なのでeach内の処理の結果を外で使いたい場合は、ブロックに対して外で定義した変数を渡す必要があります。

//emlist{
list = (1..3).to_a

result = []
list.each { |item| result << item + 10 }
p result
//}

よく似た制御構造としてforが存在しますがRubyにおいては原則使いません。

前章で紹介したRubocopにおいても、デフォルトの設定ではforの利用は禁止となっています。
またRubocopが採用しているコーディングスタイル「Ruby Style Guide」においても、
for文は避けるように書かれています。

https://github.com/fortissimo1997/ruby-style-guide/blob/japanese/README.ja.md#no-for-loops
```
forは、どうしても使わなければいけない明確な理由が明言できる人以外は、使ってはいけません。 
```
理由は簡単に言うと2つあるようです。
 1. Rubyではforは実際にはeachとして実装されている
 2. forはeachと異なり新しいスコープが導入されない
ただ本題からずれるので詳細な説明はここでは割愛します。

=== eachの弱点
ただ前述のRubyにおける反復処理の考え方 ＝ オブジェクトの各要素に、「ある処理」を適用する事
と考えると、eachメソッドにも足りない部分があります。





図XXXを例に説明

実際に先ほどのコードを見てみる。
「オブジェクトに適用したい処理」はこれだけだが、
eachのコード上は他の処理も存在する。

他の処理＝処理の結果をどうまとめるか？
この処理は必要ない

「なんかうまく説明する」
「具体的な処理をループの中に記述する」、「C言語的な手続き型の発想に囚われたまま」
という感じ。

eachは「オブジェクト内の各要素に適用したい処理」と、「処理の結果をどうまとめるか？」が同じ抽象レベルで扱われている。
Ruby的にはイケてない。
「処理の結果をどうまとめるか？」はEnumerableのメソッドで隠蔽するんだ！

== Enumerableのメソッド
前節で説明した通りeachを使った場合には、「オブジェクト内の各要素に適用したい処理」と「処理の結果をどうまとめるか？」を切り離す事ができません。

そこで登場するのがmapやselectに代表されるEnumerableモジュールのメソッドです。
Enumerableモジュールのメソッドを用いると、「オブジェクト内の各要素に適用したい処理」と「処理の結果をどうまとめるか？」の切り離しが、
簡潔なコードで実現できる。

=== Enumerableモジュールとは？

```
Enumerableモジュールは、配列やハッシュなど集合を表すクラスに数え上げや検索などのメソッドを提供します。

Enumerableモジュールのメソッドはすべて、オブジェクトのeachメソッドを呼び出します。
自作のクラスにEnumerableモジュールをインクルードするには、eachメソッドを実装する必要があります。
```

Enumerableメソッドは内部でeachメソッドを使っている。

=== Enumerableのメソッド
前述の通り、
本書ではEnumerableを、
「処理の結果をどうまとめるか？」毎に

mapを用いたenumerableの利用例

実際に図のeachをmapで書き直してみる

「処理の結果をどう扱うか」が、mapの中に組み込まれて隠蔽されている事がわかる

繰り返し処理の目的を抽象化している？

繰り返す処理とその目的

目的毎にEnumerableのメソッドを紹介する。

このような形で適切にメソッドを用いれば、
Rubyっぽいコードが実現できる？

=== Enumerableの様々なメソッド
(ここから読んで役に立つような書き方にしたいところ)
Enumerableを使うとRubyっぽいコードをかけるが、
「処理の結果をどう扱うか」を含んでいることから、1つ1つのメソッドは汎用性に欠ける。

そのため、目的に応じて適切なメソッドを使い分ける必要がある。

ここでは目的別に利用頻度のたかそうなEnumerableのメソッドを紹介する。
ひとまずここに書かれたものを使いこなせれば、
反復処理はかなりRubyっぽくなるはず。

==== map: 繰り返し処理の結果を配列にする
==== select: 繰り返し処理(条件式)の結果がtrueになる要素だけを配列にして返す
==== group_by: 繰り返し処理で指定した値を元に、ハッシュを作成する
グループ化のkeyとなる値の算出方法を渡している。

